## Guava Cache 分析

### guava的单线程回源

缓存的更新有两种方法:

- 被动更新：先从缓存获取，没有则回源获取，再更新缓存；
- 主动更新：发现数据改变后直接更新缓存（在分布式场景下，不容易实现）

在高并发环境，被动回源是需要注意的。
问题：高并发场景下，大量请求在同一时间回源，大量的请求同一时间穿透到后端，容易引起后端服务崩溃（也容易引起并发问题）。

guava 解决办法：
guava保证单线程回源，对于同一个key，只让一个请求回源load，其他线程阻塞等待结果。同时，在Guava里可以通过配置expireAfterAccess/expireAfterWrite设定key的过期时间，key过期后就单线程回源加载并放回缓存。

这样通过Guava Cache简简单单就较为安全地实现了缓存的被动更新操作。

但是如果对于同一时间大量不同的key同时过期，造成大量不同的key同时回源，这种怎么解决呢？


>1.将key的过期时间加个随机值，避免大家一起过期(前提是对业务不影响)，
> 2.自己控制回源的并发数，即使有一万个key要更新，也只让100个可以回源，其余的9900个等着，(可以通过Guava的Striped实现) 
> 3.在过期前主动更新，更新完成后将过期时间延长 

### guava refresh和expire刷新机制

- expireAfterAccess: 当缓存项在指定的时间段内没有被读或写就会被回收。
- expireAfterWrite：当缓存项在指定的时间段内没有更新就会被回收。
- refreshAfterWrite：当缓存项上一次更新操作之后的多久会被刷新。


### guava后台异步刷新

